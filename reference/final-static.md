

#### Refer1.
###### [ref1](https://djkeh.github.io/articles/Why-should-final-member-variables-be-conventionally-static-in-Java-kor/)

```
final 변수
해당 변수가 생성자나 대입연산자를 통해 한 번만 초기화 가능함을 의미합니다. 상수를 만들 때 응용합니다.
final 메소드
해당 메소드를 오버라이드하거나 숨길 수 없음을 의미합니다.
final 클래스
해당 클래스는 상속할 수 없음을 의미합니다. 문자 그대로 상속 계층 구조에서 ‘마지막’ 클래스입니다.
보안과 효율성을 얻기 위해 자바 표준 라이브러리 클래스에서 사용할 수 있는데, 대표적으로 java.lang.System, java.lang.String 등이 있습니다.
```

```
1. final 멤버 변수가 반드시 상수는 아닙니다
왜냐면 final의 정의가 ‘상수이다’가 아니라 ‘한 번만 초기화 가능하다’이기 때문입니다. 
```

```
2. private 메소드와 final 클래스의 모든 메소드는 명시하지 않아도 final 처럼 동작합니다
왜냐면 오버라이드가 불가능하기 때문이죠.

하지만 private 메소드에 여전히 final 명시는 가능합니다. 불필요하냐구요? 네 사실 그렇습니다 ㅎㅎ 그래도 일단 의미는 구분됩니다.

private: 자식 클래스에서 안 보입니다. (오버라이드도 물론 금지입니다.)
final: 자식 클래스에서 보이지만, 오버라이드가 금지됩니다.

이렇게 불필요한 명시를 그렇다고 특별 취급해서 막을 필요는 없기 때문에, 컴파일러가 에러를 내거나 경고하지는 않습니다. 비슷한 예로 인터페이스의 메소드에 public을 붙이거나, final 클래스 메소드에 final을 붙이는 등의 경우도 문제가 생기지는 않지요.
그렇다면 private 메소드와 final 메소드는 inline 메소드로 컴파일러 최적화가 될까요? 확인해보진 않았습니다만, 가능은 하더라도 항상 보장되진 않을 것으로 보입니다. 최적화 동작은 컴파일러와 내부 세팅에 의해 일어나기 때문입니다.

```
