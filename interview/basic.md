## 예상 질문

### 질문 1. 스프링 기반의 API 서버를 개발했다고 쓰여있는데 REST API 아시나요?
      REST는 아키텍처 스타일입니다. 아키텍처 스타일은 "제약 조건의 집합"을 의미하는데요.
      따라서 REST API는 "REST라는 제약조건의 집합을 충족하는 API라고 생각합니다."
      
      REST 안에 포함되는 제약조건들은 client-server, stateless, cache, uniform interface, layered system등이 있습니다. 
      제가 생각하는 중요한 제약조건은 stateless와 uniform interface가 있다고 생각하는데요.
      stateless는 Server가 Client에 대한 어떠한 상태도 저장하지 않음을 의미합니다.
      이로인해 클라이언트는 인증을 위한 Token이나 Key등을 Request에 포함시켜 전송해야 하게 됩니다.
      

##### 질문 1-1. 그럼 사용자가 요청 할때마다 Token을 넣어서 보내줘야 하는거네요? 그럼 오히려 불편한거 아니에요? 왜 굳이 그렇게 만들어야 하나요?

      만약에 Stateful한 제약조건을 허용하게 되어버리면 서버가 여러개일때 사용자에 대한 정보를 매번 동기화 해줘야합니다.
      예를들면 대규모 환경에서 동일한 웹서버를 다수 배치해 로드밸런싱을 할 때 각 서버가 Client의 상태와 세션을 공유할 수 있는 Redis와 같은 별도의 시스템이 필요하게 됩니다. 
      
      
##### 질문 1-2. Redis에 대해 잘 아시나요?

    아뇨 잘 모르고 인메모리 디비라는 것만 알고 있습니다.
    

##### 질문 1-3. 아 .. 그런가요? 아까 unfiform interface도 중요하다고 한 거 같은데 왜 그런가요?

      REST 아키텍처 스타일에서 uniform interface를 제외한 나머지 것들은 HTTP만 잘 따라도 지킬 수 있지만 uniform inerface도 아키텍처 스타일이어서요. 안에 제약조건들이 있는데
      그 중에 HATEOAS와 self-descriptive message라는 조건들을 충족시키지 못하는걸로 알고 있습니다. 그래서 REST API를 구현하려면 이 부분을 신경써야 한다고 알고 있습니다.
      
      
##### 질문 1-4. HATEOAS랑 self-descriptive message가 무슨 의미에요?
      (1) HATEOAS는 하이퍼 링크를 이용해 애플리케이션 상태 전이가 일어나야 한다는 조건이고
      (2) self-descriptive message라는건 보내는 데이터가 어떤 것인지도 명확히 설명해 줘야 한다는 얘기입니다. 예를들면 jsonPatch등에 대한 명세가 있습니다.
      [아래 학습용 사진 첨부]
      
<img width="310" alt="45674567456745672" src="https://user-images.githubusercontent.com/68278903/192554241-9bc67a5a-d3e3-4808-b05c-5d0ee971aeaa.PNG"> <img width="480" alt="4756745674567" src="https://user-images.githubusercontent.com/68278903/192549422-26fddfa3-834d-40dc-8bfa-1ea5ee8f77f9.PNG">

      
##### 질문 1-5. Uniform-interface를 안쓰면 어떻게 되는데요?
      Uniform Interface를 지켜주지 못하면 로이 필딩이 처음 HTTP/1.0을 구현할때 가장 고민했던 "독립적인 진화"를 보장할 수 없게 됩니다.
      

### 질문 2. CSRF 방어를 했다고 하는데 CSRF는 왜 필요하고 어떻게 운용했나요?
    
    CSRF는 사용자가 피싱 사이트등에 접속해서 저희 사이트에서 요구하는 인증 정보를 입력하면
    해당 사이트에서 저희 서버로 인증 정보를 보내 "인증 상태"를 탈취하는 공격입니다.
    
    그래서 우리 사이트에 접속한 유저인지 확인하기 위해 referrer 검증등의 작업을 하긴 하지만
    referrer 검증이 불가한 환경에 대해서 사용하는게 CSRF Token을 발급하는 방법입니다.
    
    저는 CSRF Token을 발급하는 방법을 썼었는데, flask의 경우 flask-WTF라는 도구를 이용해 토큰 발급및 유효성 검사를 해주었습니다.
    클라이언트로 토큰을 내려주고 ajaxSetup의 beforeSend 옵션을 이용해 ajax 요청을 보낼때 csrf 토큰을 담아 보내주도록 하는 방법으로 CSRF 방어를 운용 했습니다.


### 질문 3. 아.. 그런가요? 음 .. XSS 공격 방어를 했다는데 XSS 공격이 뭐고 어떻게 방어했나요?
     
    먼저 예를 들어 설명하면, 댓글 같은 것들은 사용자의 입력이 다시 사용자에게 랜더링 되게 되는데
    이 경우 사용자가 댓글작성을 통해 스크립트를 주입할 경우 해당 댓글을 랜더링 받는 모든 사용자가 스크립트 공격을 받게 됩니다.
    이를 stored XSS라고 하고 Reflected라고 uri의 쿼리에 스크립트를 삽입하는 방법등도 있습니다.
    
    저희 서비스는 검색 기능이 없어서 Reflected XSS를 고려할 필요가 없었기에 stored XSS만 방어토록 했습니다.
    
    어떻게 해결했냐면 기존 flask 프로젝트에선 sanitzier라는 XSS 방어용 도구를 이용해 삽입된 스크립트를 전처리 해주는 모듈을 만들어 댓글등이 Insert 되기 직전에 전처리해주었습니다. 
    하지만 이 방법을 이용하면 개발자가 일일이 공격받을 수 있는 데이터를 파악해야 하고, 객체지향적이지 못한 코드라고 생각했습니다.
    그래서 네이버에서 만든 Lucy-XSS-filter를 이용하려 했지만 저희 서비스는 json 형태로 요청이 들어와 해당 filter를 사용할 수 없었습니다.
    최종적으로 WebMvcConfigurer의 jsonEsacpeConverter를 재정의해 문제를 해결했습니다.


### 질문 4. EB를 쓰셨다고 하셨는데 EB가 뭔가요?

     EC2를 이용해 직접 배포하면 오토 스케일링, 로드밸런싱 등의 작업이 복잡합니다.
     이를 쉽고 편리하게 도와주는게 Elastic Beanstalk입니다.


### 질문 5. RDS를 왜 쓰셨나요?
    EC2에 데이터베이스를 직접 설치해 운용하는게 한달 남짓한 짧은 개발 기간에 적합하지 않다고 생각했습니다.
    기존에 flask 프로젝트에서 mongodb cluster라는 클라우드 db를 사용했을때 개발과 배포가 편리해짐을 경험해서
    스프링 프로젝트에도 RDS를 도입했습니다.
    
### 질문 6. Route53은 왜 써준거죠?
    
    AWS에서 제공하는 DNS(Domain Name Service)입니다. 
    ElasticeBeanstalk나 CloudFront와 쉽게 연동해서 사용할 수 있다는 장점이 있어서 사용했습니다.

### 질문 7. CloudFront가 뭐에요?

    AWS에서 제공해주는 CDN 입니다. 캐싱을 적용할 수 있는 리소스를 S3라는 오브젝트 스토리지에 저장해서
    이와 연동해 사용할 수 있습니다.

### 질문 8. 코드에 보니까 Builder 패턴을 사용하셨던데 이게 뭐고 왜 써주셨나요?

    빌더 패턴은 생성자 생성시에 파라미터를 보다 안전하고 명료하게 관리하기 위해 사용합니다.
    생성자 파라미터가 유독 많은 클래스들이 있어서 도입했는데 전체적인 코드의 통일성을 위해 다 같이 써주기로 했습니다.
    

### 질문 10. 전역적 예외처리를 왜 해주신거에요?
    에러를 체계적으로 관리하기 위해 @RestControllerAdvice를 이용해 해주었습니다.

##### 질문 10-1. 이거 인벨리드 익셉션이요. 이렇게 해놓고 하위 레포지토리에서 사용하면 이슈 생길 수 있는데 그거 인지하고 계세요?
     
    아뇨 .. 도저히 왜 그런지 모르겠슴니당 ..


### 질문 11. 협업을 잘 하기 위해 노력했다고 하는데 git을 이용하면서 충돌 같은걸 경험해보신 적 있나요? 어떻게 해결하셨나요?

    flask 프로젝트를 할 때 작업 공간을 프론트앤드 관점으로 분리했었습니다. 때문에 백앤드 작업을 할 때
    충돌이 잦았습니다.
    
    저는 이 문제를 서비스 자체는 모놀리식 구조이지만 내부적으로 도메인에 맞는 패키지를 나누어서 작업공간을 분리해서 해결했는데
    이 덕분에 config 파일을 수정하는 경우 외에는 충돌을 단 한번도 겪지 않았습니다.


### 질문 12. EC2에 서버는 뭐로 해주셨나요?

    EC2에 서버는 NGINX를 이용했습니다. 
    

### 질문 13. 이력서에 JPA가 쓰여져있는데, JPA가 뭐고 왜 써주는거죠?
    JPA는 자바 진영의 ORM 표준입니다. ORM은 객체지향과 RDB를 자동으로 매핑해주는 역할을 합니다.
    JPA의 구현체로는 Hibernate가 있는데 이를 더 쉽게 사용토록 해주는 SPRING DATA JPA를 이용했습니다.

### 질문 14. 아까 쿠키에 대해서 얘기하셨는데, 쿠키에 뭘 담아서 보내본적이 있으신가요?
    네! CSRF 보안을 위해 CSRF 토큰을 내려 보안 처리 한 경험이 있습니다. 
    또 인증을 위해 JWT를 담아 보낸 경험이 있습니다!
